<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KFTamang Blog</title>
    <link>https://KFTamang.github.io/tags/%E5%80%92%E7%AB%8B%E6%8C%AF%E5%AD%90/index.xml</link>
    <description>Recent content on KFTamang Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="https://KFTamang.github.io/tags/%E5%80%92%E7%AB%8B%E6%8C%AF%E5%AD%90/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NT金沢2019に出展してきました</title>
      <link>https://kftamang.github.io/post/nt_kanazawa/</link>
      <pubDate>Mon, 15 Jul 2019 21:53:44 +0900</pubDate>
      
      <guid>https://kftamang.github.io/post/nt_kanazawa/</guid>
      <description>

&lt;h1 id=&#34;nt金沢に出展してきました&#34;&gt;NT金沢に出展してきました&lt;/h1&gt;

&lt;p&gt;少し前になりますが、2019/6/29,30に石川県金沢で開催されたNT金沢2019年に出展してきました(参考：&lt;a href=&#34;http://nt-kanazawa.org/&#34;&gt;NT金沢2019&lt;/a&gt; )。
少し遅くなりましたが、その時の報告をしたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;nt金沢とはどのようなイベントなのか&#34;&gt;NT金沢とはどのようなイベントなのか&lt;/h3&gt;

&lt;p&gt;NTとはNico Techの略で、ニコニコ技術部のコミュニティから生まれたものづくり展示のイベントです。
イメージとしてはものづくり版の同人即売会といえばいいんでしょうか。（同人即売会行ったことないけど）&lt;/p&gt;

&lt;p&gt;同系統のイベントとしては有名なものにMaker Faireというものがありますが、
ニコニコ技術部に由来することからNTは比較的ゆるく、ネタに走った展示が多いような印象があります。
昔からニコニコ技術部を見て育ったため、自分が展示者側に回るというのは感慨深いものがあります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://KFTamang.github.io/images/P_20190629_170321_vHDR_On.jpg&#34; alt=&#34;NT金沢の様子1&#34; /&gt;
&lt;img src=&#34;https://KFTamang.github.io/images/P_20190629_170338_vHDR_On.jpg&#34; alt=&#34;NT金沢の様子2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;金沢駅隣接の地下空間を借り、そこに長机と椅子をならべて様々な展示者がそれぞれの作品を展示していました。
印象に残ったのは和さん(&lt;a href=&#34;https://twitter.com/iris_0xff&#34;&gt;@iris_0xff&lt;/a&gt;),WRFさん(&lt;a href=&#34;https://twitter.com/wrf_lab&#34;&gt;@wrf_lab&lt;/a&gt;)の製作したオムニホイールを搭載したロボットです。
自分が3年生のときと比べると、作品を完成まで作りきるということができていて自主性と根気が素晴らしいですね。&lt;/p&gt;

&lt;h1 id=&#34;自分の出展内容&#34;&gt;自分の出展内容&lt;/h1&gt;

&lt;p&gt;出展内容はこのブログでも製作過程を報告してきた倒立振子です。
出展に際して3Dプリンタで筐体を製作したりしました。
ニコニコ技術部ということでネギ型の筐体をモデリングして倒立振子によるネギ振りをしたかったのですが、いまいち安定させることができませんでした。
10秒ほどは立ってくれますが、たまに大きく加速してそのままリカバリーできずに倒れてしまいます。
多少は立てるので、PID制御の係数が大きく外れた値を使っているということがないと思います。
今はジャイロセンサの値取得にかかる時間が一定でないことが原因でないかと疑っています。&lt;/p&gt;



&lt;p&gt;また、ジャイロ・加速度センサからの角度をリアルタイムにグラフ表示するデモも行いました
（画質が足りなくて線が見にくいです）。&lt;/p&gt;



&lt;p&gt;モータの出力も安定度に影響するようなので、ステッピングモータの導入も含めて考えています。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;思いつきで申し込み、本番2週間くらい前から慌てて筐体を作り始めた今回でしたが、
非常によい経験になりました。
数ヶ月に一度は開催され、かつ適度にゆるいNTのようなイベントはモチベーション維持にとても効果的だと思うので、これからも継続的に参加していきたいです。&lt;/p&gt;

&lt;p&gt;最後に、イベントで知り合った皆様、そして何より運営の皆様、どうもありがとうございました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[倒立振子] 角度の推定</title>
      <link>https://kftamang.github.io/post/inverse_pendulum_3/</link>
      <pubDate>Sat, 04 May 2019 11:41:00 +0900</pubDate>
      
      <guid>https://kftamang.github.io/post/inverse_pendulum_3/</guid>
      <description>

&lt;h1 id=&#34;前回までのまとめ&#34;&gt;前回までのまとめ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://kftamang.github.io/post/inverse_pendulum_2&#34;&gt;前回&lt;/a&gt;は倒立振子の完成に向けてモータのPWM制御を行った。
そのとき次回は全体のまとめについて記事にすると言ったが、
角度の推定だけでひとつのエントリにした方が良さそうなので分割することにした。&lt;/p&gt;

&lt;h1 id=&#34;姿勢の取得&#34;&gt;姿勢の取得&lt;/h1&gt;

&lt;p&gt;倒立振子が自立するには垂直軸に対する自分の角度を知る必要がある。
このためにジャイロセンサ・加速度センサ複合モジュールである
&lt;a href=&#34;https://www.amazon.co.jp/gp/product/B00K67X810/ref=ppx_yo_dt_b_search_asin_title?ie=UTF8&amp;amp;psc=1&#34;&gt;GY-521 MPU-60503軸ジャイロ+3軸加速度センサ&lt;/a&gt;
を用いた。
GY-521はジャイロ・加速度センサチップであるMPU-6050にパスコン、3端子レギュレータなどを合わせて2.54mmピッチに変換したものである。
ArduinoとはI2C方式で通信する。&lt;/p&gt;

&lt;p&gt;ジャイロセンサにより3軸の角速度、加速度センサにより同じく3軸の加速度が取得できる。
ジャイロセンサのみ、または加速度センサのみで現在の角度を求めることも可能ではあるが、
後述する通り両者を組み合わせることで精度を向上させることができる。&lt;/p&gt;

&lt;h2 id=&#34;角度の推定方法&#34;&gt;角度の推定方法&lt;/h2&gt;

&lt;p&gt;ジャイロセンサは角速度を測定するため、測定値を積分することで始点からの角度変化を求めることができる。
しかしこの方法では測定値を足しつづけるため、誤差が蓄積し推定値が真の値からどんどんずれてしまう。&lt;/p&gt;

&lt;p&gt;加速度センサは重力加速度の方向がわかるため、垂直軸からの離角が直接計算できる。
しかし加速度センサはノイズが大きく、瞬間的には角度の計算値は大きく揺れる。
また水平方向に加速運動をしている場合、慣性力と重力加速度の合力が測定されるため計算値に誤差が乗る。&lt;/p&gt;

&lt;p&gt;そこで今回は相補フィルターを用いてジャイロセンサと加速度センサの値から角度を推定した。&lt;/p&gt;

&lt;p&gt;相補フィルタについては各自参照してもらいたいが、長期トレンドとしては加速度センサが、短期トレンドとしてはジャイロセンサが大きな影響を与えるようになっている。&lt;/p&gt;

&lt;p&gt;ジャイロセンサ・加速度センサのテストに用いたコードが以下である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gyro_test&#34;&gt;// MPU-6050 Short Example Sketch
// By Arduino User JohnChi
// August 17, 2014
// Public Domain
#include&amp;lt;Wire.h&amp;gt;

#define dt (0.030)
#define K (0.95)



float angle = 0;
float angle_raw = 0;
float angle_com = 0;
float angle_gyro = 0;
float gyro_offset = 0.0;
float angle_offset = 0.0;

int count = 0;

const int MPU_addr=0x68;  // I2C address of the MPU-6050
int16_t AcX,AcY,AcZ,Tmp,GyX,GyY,GyZ;
void setup(){
  Wire.begin();
  Wire.beginTransmission(MPU_addr);
  Wire.write(0x6B);  // PWR_MGMT_1 register
  Wire.write(0);     // set to zero (wakes up the MPU-6050)
  Wire.endTransmission(true);
  Serial.begin(115200);

  // canceling gyro offset
  for(int i=0;i&amp;lt;100;++i){
    Wire.beginTransmission(MPU_addr);
    Wire.write(0x3B);  // starting with register 0x3B (ACCEL_XOUT_H)  
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_addr,14,true);  // request a total of 14 registers
    AcX=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x3B (ACCEL_XOUT_H) &amp;amp; 0x3C (ACCEL_XOUT_L)     
    AcY=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x3D (ACCEL_YOUT_H) &amp;amp; 0x3E (ACCEL_YOUT_L)
    AcZ=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x3F (ACCEL_ZOUT_H) &amp;amp; 0x40 (ACCEL_ZOUT_L)
    Tmp=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x41 (TEMP_OUT_H) &amp;amp; 0x42 (TEMP_OUT_L)
    GyX=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x43 (GYRO_XOUT_H) &amp;amp; 0x44 (GYRO_XOUT_L)
    GyY=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x45 (GYRO_YOUT_H) &amp;amp; 0x46 (GYRO_YOUT_L)
    GyZ=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x47 (GYRO_ZOUT_H) &amp;amp; 0x48 (GYRO_ZOUT_L)
    gyro_offset += GyZ;
    angle_offset += atan2(AcX,AcY)*180.0/3.14 + 90.0;
  
  }
  gyro_offset /= 100.0;
  angle_offset /= 100.0;
  
  Serial.print(gyro_offset);
  Serial.print(&amp;quot;\n&amp;quot;);
  
}

void loop(){
  ++count;  
  //angle = get_angle();

  Wire.beginTransmission(MPU_addr);
  Wire.write(0x3B);  // starting with register 0x3B (ACCEL_XOUT_H)
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_addr,14,true);  // request a total of 14 registers
  AcX=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x3B (ACCEL_XOUT_H) &amp;amp; 0x3C (ACCEL_XOUT_L)     
  AcY=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x3D (ACCEL_YOUT_H) &amp;amp; 0x3E (ACCEL_YOUT_L)
  AcZ=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x3F (ACCEL_ZOUT_H) &amp;amp; 0x40 (ACCEL_ZOUT_L)
  Tmp=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x41 (TEMP_OUT_H) &amp;amp; 0x42 (TEMP_OUT_L)
  GyX=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x43 (GYRO_XOUT_H) &amp;amp; 0x44 (GYRO_XOUT_L)
  GyY=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x45 (GYRO_YOUT_H) &amp;amp; 0x46 (GYRO_YOUT_L)
  GyZ=Wire.read()&amp;lt;&amp;lt;8|Wire.read();  // 0x47 (GYRO_ZOUT_H) &amp;amp; 0x48 (GYRO_ZOUT_L)


  angle = atan2(AcX,AcY)*180.0/3.14 + 90.0 - angle_offset;

  float d_gyro = (GyZ-gyro_offset)*dt/32768*250; 
  angle_gyro += d_gyro; // 32768:max int, 250 deg/sec max rate
  
  
// complimentary filter 
  angle_com = K*(angle_com + d_gyro) + (1-K)*angle;


  Serial.print(angle);
  Serial.print(&amp;quot; &amp;quot;);
  Serial.print(angle_com);
  Serial.print(&amp;quot;\n&amp;quot;);

  delay(100);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動時に実行されるsetup()ではジャイロセンサのオフセットを除去するため、
データを100回取って平均している。
このとき機体は静止していることを前提としているためなるべく動かさないようにする。
以降はこの平均をジャイロセンサの値から引いて使用している。
また、同時に加速度センサも100回の平均を取り、これを垂直の値として使用している。
これは制御の角度原点となるため、ここが垂直になっていないと倒立振子が横に動いていってしまう。&lt;/p&gt;

&lt;p&gt;角度計算のコードのなかでジャイロセンサからの角度の値を積分するのにデータ取得間隔としてdtを掛けている。
このdtはdelay()の値やシリアル通信、そのほかの処理にかかる時間によって変化する。
そのため、処理ごとにデータ取得間隔を実測してdtの値を決定しなければいけない。&lt;/p&gt;

&lt;p&gt;dtの値が間違っていると、ジャイロセンサからの角度の推定値が大きすぎ、または小さすぎてしまうため、機体を回転させると正しい値がでなくなる。（数秒待つと加速度センサの寄与により正しい値になっていく。）&lt;/p&gt;

&lt;h1 id=&#34;実際のデータの確認&#34;&gt;実際のデータの確認&lt;/h1&gt;

&lt;p&gt;確認のため角度を0度から約90度に手で起こし、また0度に戻したときのジャイロセンサ、加速度センサ、相補フィルタ出力の3つを比較したグラフを載せる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://KFTamang.github.io/images/ 2019-05-19 at 20.50.07.png&#34; alt=&#34;angle_plot&#34; /&gt;
青線が加速度センサ、赤線がジャイロセンサ、緑線が相補フィルタ出力となっている。
青の加速度センサはノイズが多く、短期的にはあまり当てにならないことがわかる。
拡大すると見えるが赤のジャイロセンサは0度がずれていっている。（オフセット除去によりドリフトはそれなりに抑えられている。）
&lt;img src=&#34;https://KFTamang.github.io/images/ 2019-05-19 at 20.56.09.png&#34; alt=&#34;angle_plot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;緑の相補フィルタは青のノイズを抑えながら赤に追従し、かつ原点のドリフトを抑えられている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>モータドライバのPWM制御のテスト</title>
      <link>https://kftamang.github.io/post/inverse_pendulum_2/</link>
      <pubDate>Tue, 23 Apr 2019 14:04:18 +0900</pubDate>
      
      <guid>https://kftamang.github.io/post/inverse_pendulum_2/</guid>
      <description>

&lt;h1 id=&#34;これまで&#34;&gt;これまで&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://kftamang.github.io/post/inverse_pendulum_1/&#34;&gt;前回の記事&lt;/a&gt;でモータドライバIC DRV8835の動作テストを行い、
無事にDCモータ(FA-130)が駆動できることを確認しました。
しかしこのままではモータの動作は順方向逆方向に最大出力の運転しかできません。
倒立振子を製作するには、0%から100%の間で出力を連続的に変化させてモータを駆動する必要があります。&lt;/p&gt;

&lt;p&gt;今回はPWM方式を用いてモータの出力を変化させるテストをしました。&lt;/p&gt;

&lt;h1 id=&#34;pwm方式&#34;&gt;PWM方式&lt;/h1&gt;

&lt;p&gt;PWMとはPulse Width Modulationの略で、High/Lowの2値しかとらない信号線一本で連続的な量を送る変調方式の一種です。
周期的なパルスを送信する際に、パルスのDuty比(Highである時間とLowである時間の比)によって連続量を表現します。
受け手の時間応答よりも十分早い周波数でパルスを送ることで、実効的には時間平均が取られた値を送ることができます。
今回使用したArduino nanoではPWMの周波数は約490Hzであり、モータの応答に対して十分早いため回転スピードを連続的に変化させることができます。&lt;/p&gt;

&lt;h1 id=&#34;実験系&#34;&gt;実験系&lt;/h1&gt;

&lt;p&gt;PWM信号を送るため、Arduino nanoを使用しました。
ArduinoはPWM信号を送るためのanalogWrite()関数が用意されており、
簡単に特定のピンから約490HzのPWM信号を出力できます。（一部のピンでは倍の周波数で出る。）
またDRV8835をPHASE/ENABLEモードで動作させるにあたり、順転逆転の制御のためのPHASE信号も必要となります。&lt;/p&gt;

&lt;p&gt;Arduino nanoの3.3V,GND,PIN9,PIN8をそれぞれDRV8835のVCC,GND,AENABLE,APHASEにつなぎました。
PHASE/ENABLEモードで動作させるためDRV8835のMODEピンは3.3Vに直結します。&lt;/p&gt;

&lt;p&gt;DRV8835のVM,GND,AOUT1/AOUT2を電池、モータに繋いで準備完了です。&lt;/p&gt;

&lt;h1 id=&#34;テスト用のarduinoスケッチ&#34;&gt;テスト用のArduinoスケッチ&lt;/h1&gt;

&lt;p&gt;以下にテストに使用したスケッチを置いておきます。
出力を0%からほぼ100%に上げ、また0%に戻すのを順転方向と逆転方向について交互に繰り返すだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp:PWM_test&#34;&gt;int pwm_out = 9;
int phase = 8;
void setup() {
  // put your setup code here, to run once:
  pinMode(pwm_out, OUTPUT);
  pinMode(phase, OUTPUT);
  
}

void loop() {
  // put your main code here, to run repeatedly:
  digitalWrite(phase, HIGH);
  for (int i = 0; i &amp;lt; 25; ++i) {
    analogWrite(pwm_out, i * 10);
    delay(200);
  }
  for (int i = 25; i &amp;gt; 0; --i) {
    analogWrite(pwm_out, i * 10);
    delay(200);
  }
  digitalWrite(phase, LOW);
  for (int i = 0; i &amp;lt; 25; ++i) {
    analogWrite(pwm_out, i * 10);
    delay(200);
  }
  for (int i = 25; i &amp;gt; 0; --i) {
    analogWrite(pwm_out, i * 10);
    delay(200);
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;結果&#34;&gt;結果&lt;/h1&gt;

&lt;p&gt;意図したとおりにモータの出力が変化してくれます。
車輪に目印を貼って回転速度がわかる様にすればよかったですね。&lt;/p&gt;



&lt;h1 id=&#34;次回予告&#34;&gt;次回予告&lt;/h1&gt;

&lt;p&gt;次はいよいよ傾きセンサと組み合わせていきたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ギアボックスとモータ駆動系の製作</title>
      <link>https://kftamang.github.io/post/inverse_pendulum_1/</link>
      <pubDate>Sun, 21 Apr 2019 12:49:27 +0900</pubDate>
      
      <guid>https://kftamang.github.io/post/inverse_pendulum_1/</guid>
      <description>

&lt;h1 id=&#34;倒立振子製作にむけて&#34;&gt;倒立振子製作にむけて&lt;/h1&gt;

&lt;p&gt;倒立振子（とうりつしんし）とは、棒の先に重りをつけた振子を逆さに立てた系のことです。
当然そのままでは倒れてしまいますが、制御を加えることで逆立ちを維持させることができます。
フィードバック制御の課題としてよく取り上げられる題材であり、わたしはArduinoの練習ということで製作してみたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;今回の内容&#34;&gt;今回の内容&lt;/h1&gt;

&lt;p&gt;倒立振子には制御を行う演算系と、実際の制御を行う機械系が必要になります。
今回は機械系としてDCモータでタイヤを駆動する1次元系にしました。&lt;/p&gt;

&lt;p&gt;以下に部品のリストを示します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tamiya.com/japan/products/70093/index.html&#34;&gt;3速クランクギアボックスセット - タミヤ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tamiya.com/japan/products/94380/index.html&#34;&gt;DCモータ FA-130 - タミヤ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tamiya.com/japan/products/70096/index.html&#34;&gt;オフロードタイヤセット - タミヤ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gK-09848/&#34;&gt;ＤＲＶ８８３５使用ステッピング＆ＤＣモータドライバモジュール - 秋月電子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;モータは親の顔よりよく見たミニ４駆用DCモータです。これはマブチモータ互換品であり、マブチ製品の型番はFA-130RAというようです。
性能表は&lt;a href=&#34;https://product.mabuchi-motor.co.jp/detail.html?id=9&#34;&gt;ここ&lt;/a&gt;にあります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://KFTamang.github.io/images/ScreenShot2019-04-21at131244.png&#34; alt=&#34;モータ性能表&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これを見ると、電圧は1.5-3.0Vのようです。ネット上でロボコンなどの記事を見ると過電圧をかけることも可能なようですが、
定格に準拠したいと思います。&lt;/p&gt;

&lt;p&gt;今回はこのモータを秋月のドライバICキットで動かすところまでやりたいと思います。&lt;/p&gt;

&lt;h1 id=&#34;ギアボックス-モータの組み立てと動作確認&#34;&gt;ギアボックス、モータの組み立てと動作確認&lt;/h1&gt;

&lt;p&gt;説明書に沿って組み立てます。ギア比は中速(&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;58&lt;/sub&gt;.2減速)を選びました。
モータを3Vに接続してのテストがこちら。&lt;/p&gt;



&lt;h1 id=&#34;ドライバicによるモータ制御&#34;&gt;ドライバICによるモータ制御&lt;/h1&gt;

&lt;p&gt;秋月のモータドライバICキットでモータをコントロールできるかテストします。
今回購入したキットにはDRV8835が使用してあります。
この&lt;a href=&#34;http://akizukidenshi.com/download/ds/ti/drv8835.pdf&#34;&gt;DRV8835のデータシート&lt;/a&gt;を見ると、
定格1.5Aのチャンネルが二つあり、並列に繋げることで最大3Aまでドライブできるようです。
FA-130の性能表を見ると無負荷(NO LOAD)で0.20A、静止時(STALL)で2.20Aの電流が流れるとのことです。
本番では偶然壁にぶつかってしまうこともあると思うので2chを並列に接続しますが、
今のテストでは1chだけでいいでしょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://KFTamang.github.io/images/ScreenShot2019-04-21at144952.png&#34; alt=&#34;DRV8835&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ブレッドボードに動作テスト用の回路を組みます。
DRV8835に電源を与えて入力の2つの入力のロジックレベルを変えてやると、
表にしたがって回転方向が変化します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://KFTamang.github.io/images/P_20190421_155506_vHDR_Auto.jpg&#34; alt=&#34;ブレッドボードテスト&#34; /&gt;
ブレッドボードでテストをしている様子。
モバイルバッテリーから電圧を3.3Vへ落としてICへ供給している。反対側にはモータ駆動用の電池が繋がっている。&lt;/p&gt;

&lt;p&gt;入出力の対応には2種類のモードがあり、それぞれIN/INモードとPHASE/ENABLEモードと呼ばれています。
IN/INモードではCoast(空転)が使えますが、ReverseのときにON/OFFがややこしくなります。
その点、PHASE/ENABLEモードではCoastが使えない代わりに、ReverseでもON/OFFの操作がForwardと同じになります。&lt;/p&gt;

&lt;p&gt;倒立振子の運動を考えると、常に制御していないと倒れてしまうことからCoastは必要ない代わりに、
運動は前進と後進が対称です。
PWMで速度の調整を行いたいことから、動作モードはPHASE/ENABLEが適していることがわかりました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://KFTamang.github.io/images/ScreenShot2019-04-21at154930.png&#34; alt=&#34;ロジック表&#34; /&gt;
入力と出力の対応表。&lt;/p&gt;

&lt;p&gt;次回はArduinoを用いてPWMでの回転速度制御を行う予定です。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>